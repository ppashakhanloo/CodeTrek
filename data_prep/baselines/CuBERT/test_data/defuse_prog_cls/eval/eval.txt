{"function": "\n\ndef testSimpleFuncdef(self):\n    code = textwrap.dedent('\\n      def foo(x): # c1\\n        # c2\\n        return x\\n      ')\n    uwlines = self._ParseAndUnwrap(code)\n    self._CheckUnwrappedLines(uwlines, [(0, ['def', 'foo', '(', 'x', ')', ':', '# c1']), (1, ['# c2']), (1, ['return', 'x'])])\n", "label": "used", "info": "defuse/eval/used/file_1000024.py"}
{"function": "\n\ndef writelines(self, lines):\n    self.write(''.join(lines))\n", "label": "used", "info": "defuse/eval/used/file_1000034.py"}
{"function": "\n\ndef buildFeaturedImage(self, b, article):\n    s = self.style\n    b.div(class_=self.C.CLASS_FEATUREDITEM, display=s.itemDisplay, backgroundcolor=s.itemBackgroundColor, padding=s.itemPadding, clear=s.itemClear, marginbottom=s.itemMarginBottom, margintop=s.itemMarginTop, width=s.itemWidth)\n    b.a(href=('/%s-%s' % (self.C.PARAM_ARTICLE, article.id)))\n    b.img(class_=(self.C.CLASS_AUTOWIDTH, 'featuredImage'), src=article.poster)\n    if (s.showLevel or s.genericLevel):\n        b.h5(class_=self.C.CLASS_LEVEL, color=s.levelColor, fontsize=s.levelSize, fontweight=s.levelWeight, margintop=s.levelMarginTop, marginbottom=s.levelMarginBottom)\n        b.text((s.levelFormat % (article.level or s.genericLevel)))\n        b._h5()\n    if s.showTitle:\n        b.h4(class_=self.C.CLASS_TITLE, color=s.titleColor, fontsize=s.titleSize, fontweight=s.titleWeight, lineheight=s.titleLineHeight)\n        b.text(article.title)\n        b._h4()\n    if (s.showTopic and (article.topic is not None)):\n        b.h5(class_=self.C.CLASS_TOPIC, color=s.topicColor, fontsize=s.topicSize, fontweight=s.topicWeight, lineheight=s.topicLineHeight)\n        if isinstance(article.topic, basestring):\n            b.text(article.topic)\n        else:\n            self.buildElement(b, article.topic)\n        b._h5()\n    b._a()\n    b._div(comment=self.C.CLASS_FEATUREDITEM)\n", "label": "used", "info": "defuse/eval/used/file_1000066.py"}
{"function": "\n\ndef is_element_visible(self, finder, selector, wait_time=None):\n    wait_time = (wait_time or self.wait_time)\n    end_time = (time.time() + wait_time)\n    while (time.time() < end_time):\n        if (finder(selector) and finder(selector).visible):\n            return True\n    return False\n", "label": "used", "info": "defuse/eval/used/file_1000084.py"}
{"function": "\n\ndef test_get_message_with_multiline(self):\n    event_source = eventsource_connect(url=self.get_url('/multi_line'), callback=self.stop)\n    self.wait()\n    event = event_source.result().events[0]\n    self.assertEqual(event.name, None)\n    self.assertEqual(event.data, 'such Wow\\nmuch multi')\n", "label": "used", "info": "defuse/eval/used/file_1000086.py"}
{"function": "\n\ndef get_conn(opts, profile=None, host=None, port=None):\n    '\\n    Return a conn object for accessing memcached\\n    '\n    if (not (host and port)):\n        opts_pillar = opts.get('pillar', {\n            \n        })\n        opts_master = opts_pillar.get('master', {\n            \n        })\n        opts_merged = {\n            \n        }\n        opts_merged.update(opts_master)\n        opts_merged.update(opts_pillar)\n        opts_merged.update(opts)\n        if profile:\n            conf = opts_merged.get(profile, {\n                \n            })\n        else:\n            conf = opts_merged\n        host = conf.get('memcached.host', DEFAULT_HOST)\n        port = conf.get('memcached.port', DEFAULT_PORT)\n    if (not str(port).isdigit()):\n        raise SaltInvocationError('port must be an integer')\n    if HAS_LIBS:\n        return memcache.Client(['{0}:{1}'.format(host, port)])\n    else:\n        raise CommandExecutionError('(unable to import memcache, module most likely not installed)')\n", "label": "used", "info": "defuse/eval/used/file_1000126.py"}
{"function": "\n\ndef main():\n    status = {\n        \n    }\n    status['hardware_processors_status'] = get_hpasmcli_status('server')\n    status['hardware_memory_status'] = get_hpasmcli_status('dimm')\n    status['hardware_disk_status'] = get_drive_status()\n    status['hardware_controller_status'] = get_controller_status()\n    status['hardware_controller_cache_status'] = get_controller_cache_status()\n    status['hardware_controller_battery_status'] = get_controller_battery_status()\n    maas_common.status_ok()\n    for (name, value) in status.viewitems():\n        maas_common.metric_bool(name, value)\n", "label": "used", "info": "defuse/eval/used/file_1005484.py"}
{"function": "\n\ndef month_view(request, year, month, template='swingtime/monthly_view.html', queryset=None):\n    '\\n    Render a tradional calendar grid view with temporal navigation variables.\\n\\n    Context parameters:\\n    \\n    ``today``\\n        the current datetime.datetime value\\n        \\n    ``calendar``\\n        a list of rows containing (day, items) cells, where day is the day of\\n        the month integer and items is a (potentially empty) list of occurrence\\n        for the day\\n        \\n    ``this_month``\\n        a datetime.datetime representing the first day of the month\\n    \\n    ``next_month``\\n        this_month + 1 month\\n    \\n    ``last_month``\\n        this_month - 1 month\\n    \\n    '\n    (year, month) = (int(year), int(month))\n    cal = calendar.monthcalendar(year, month)\n    dtstart = datetime(year, month, 1)\n    last_day = max(cal[(- 1)])\n    dtend = datetime(year, month, last_day)\n    queryset = (queryset._clone() if (queryset is not None) else Occurrence.objects.select_related())\n    occurrences = queryset.filter(start_time__year=year, start_time__month=month)\n\n    def start_day(o):\n        return o.start_time.day\n    by_day = dict([(dt, list(o)) for (dt, o) in itertools.groupby(occurrences, start_day)])\n    data = {\n        'today': datetime.now(),\n        'calendar': [[(d, by_day.get(d, [])) for d in row] for row in cal],\n        'this_month': dtstart,\n        'next_month': (dtstart + timedelta(days=(+ last_day))),\n        'last_month': (dtstart + timedelta(days=(- 1))),\n    }\n    return render(request, template, data)\n", "label": "unused", "info": "defuse/eval/unused/file_1011062.py"}
{"function": "\n\ndef _populate_neutron_extension_values(self, context, instance, pci_request_id, port_req_body, network=None, neutron=None, bind_host_id=None):\n    'Populate neutron extension values for the instance.\\n\\n        If the extensions loaded contain QOS_QUEUE then pass the rxtx_factor.\\n        '\n    self._refresh_neutron_extensions_cache(context, neutron=neutron)\n    if (constants.QOS_QUEUE in self.extensions):\n        flavor = instance.get_flavor()\n        rxtx_factor = flavor.get('rxtx_factor')\n        port_req_body['port']['rxtx_factor'] = rxtx_factor\n    has_port_binding_extension = self._has_port_binding_extension(context, neutron=neutron)\n    if has_port_binding_extension:\n        port_req_body['port']['binding:host_id'] = bind_host_id\n        self._populate_neutron_binding_profile(instance, pci_request_id, port_req_body)\n    if (constants.DNS_INTEGRATION in self.extensions):\n        if ((not has_port_binding_extension) or (not network.get('dns_domain'))):\n            port_req_body['port']['dns_name'] = instance.hostname\n", "label": "used", "info": "defuse/eval/used/file_1011930.py"}
{"function": "\n\ndef _process(self, name, data, mode):\n    'name = filename or other ID for this processing chain\\n           data = the string to receive any processing\\n           mode = specify which processor phase currently pre or post\\n        '\n    td = data\n    for d in self.directives:\n        if (not d.supports(mode)):\n            continue\n        d.set_mode(mode)\n        try:\n            d.load(name, data)\n            if (not d.is_used()):\n                continue\n            d.is_valid()\n            data = d.apply()\n            d.reset()\n        except DirectiveException:\n            d.reset()\n            traceback.print_exc()\n    return data\n", "label": "unused", "info": "defuse/eval/unused/file_1013922.py"}
{"function": "\n\ndef _print_error(self, error):\n    self.broken = True\n    if (type(error) == dict):\n        self._print_data(error)\n    else:\n        self._print_data({\n            'error': error,\n        })\n", "label": "used", "info": "defuse/eval/used/file_1013942.py"}
{"function": "\n\ndef check_job_lock(self, command_handler):\n    'Check to see if we hold the job lock'\n    return bool((self.command_handler_holding_job_lock == command_handler))\n", "label": "used", "info": "defuse/eval/used/file_1013960.py"}
{"function": "\n\ndef it_provides_access_to_its_spTree_element_to_help(self, slide):\n    spTree = slide.spTree\n    assert isinstance(spTree, CT_GroupShape)\n", "label": "used", "info": "defuse/eval/used/file_1013990.py"}
{"function": "\n\ndef check_status(self, resp, content):\n    if (resp.status >= 400):\n        msg = 'Bulk API HTTP Error result: {0}'.format(content)\n        self.raise_error(msg, resp.status)\n", "label": "used", "info": "defuse/eval/used/file_1014012.py"}
{"function": "\n\ndef __init__(self, *args, **kwargs):\n    'Initialization.'\n    fields = kwargs.pop('fields', None)\n    super(FieldSelectorSerializer, self).__init__(*args, **kwargs)\n    if fields:\n        allowed = set(fields)\n        existing = set(self.fields.keys())\n        for field in (existing - allowed):\n            self.fields.pop(field)\n", "label": "used", "info": "defuse/eval/used/file_1014040.py"}
