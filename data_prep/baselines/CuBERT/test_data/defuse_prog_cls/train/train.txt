{"function": "\n\ndef string_to_classes(s):\n    if (s == '*'):\n        c = sorted(six.iterkeys(tracked_classes))\n        return c\n    else:\n        return s.split()\n", "label": "used", "info": "defuse/train/used/file_1279108.py"}
{"function": "\n\ndef __init__(self, board, name, uuid=None, details=None, backend=None, book=None, book_data=None):\n    if uuid:\n        self._uuid = uuid\n    else:\n        self._uuid = uuidutils.generate_uuid()\n    self._name = name\n    if (not details):\n        details = {\n            \n        }\n    self._details = details\n    self._backend = backend\n    self._board = board\n    self._book = book\n    if (not book_data):\n        book_data = {\n            \n        }\n    self._book_data = book_data\n", "label": "used", "info": "defuse/train/used/file_1279110.py"}
{"function": "\n\ndef _modifiedTest(self, modifiedSince):\n    '\\n        Given the value C{modifiedSince} for the I{If-Modified-Since}\\n        header, verify that a response with a 200 code and the resource as\\n        the body is returned.\\n        '\n    self.channel.lineReceived(('If-Modified-Since: ' + modifiedSince))\n    self.channel.lineReceived('')\n    result = self.transport.getvalue()\n    self.failUnlessEqual(httpCode(result), http.OK)\n    self.failUnlessEqual(httpBody(result), 'correct')\n", "label": "used", "info": "defuse/train/used/file_1279150.py"}
{"function": "\n\ndef test_matching_should_be_case_insensitive(completer):\n    \"Fuzzy matching should keep matches even if letter casing doesn't match.\\n\\n    This test checks that variations of the text which have different casing\\n    are still matched.\\n    \"\n    text = 'foo'\n    collection = ['Foo', 'FOO', 'fOO']\n    matches = completer.find_matches(text, collection)\n    assert (len(matches) == 3)\n", "label": "used", "info": "defuse/train/used/file_1279160.py"}
{"function": "\n\ndef test_hash_password():\n    p = 'password'\n    auth = authcode.Auth(SECRET_KEY, hash='pbkdf2_sha512', rounds=345)\n    hashed = auth.hash_password(p)\n    assert hashed.startswith('$pbkdf2-sha512$345$')\n    assert auth.password_is_valid(p, hashed)\n    assert (not auth.password_is_valid(p, 'lalala'))\n    assert (not auth.password_is_valid(p, None))\n    assert (not auth.password_is_valid(None, 'lalala'))\n    assert (not auth.password_is_valid(None, None))\n", "label": "used", "info": "defuse/train/used/file_1279164.py"}
{"function": "\n\ndef delete(self, key):\n    cursor = connection.cursor()\n    cursor.execute(('DELETE FROM %s WHERE cache_key = %%s' % self._table), [key])\n    transaction.commit_unless_managed()\n", "label": "used", "info": "defuse/train/used/file_1279174.py"}
{"function": "\n\ndef configure_led(self, config):\n    if (not self.rgb_connection):\n        self.log.critical('A request was made to configure a FAST LED, but no connection to an LED processor is available')\n        sys.exit()\n    if (not self.flag_led_tick_registered):\n        self.machine.events.add_handler('timer_tick', self.update_leds)\n        self.flag_led_tick_registered = True\n    if ('-' in config['number_str']):\n        num = config['number_str'].split('-')\n        config['number'] = ((int(num[0]) * 64) + int(num[1]))\n        self.config['config_number_format'] = 'int'\n    else:\n        config['number'] = str(config['number'])\n    if (self.config['config_number_format'] == 'int'):\n        config['number'] = Util.int_to_hex_string(config['number'])\n    else:\n        config['number'] = Util.normalize_hex_string(config['number'])\n    this_fast_led = FASTDirectLED(config['number'])\n    self.fast_leds.add(this_fast_led)\n    return this_fast_led\n", "label": "used", "info": "defuse/train/used/file_1279190.py"}
{"function": "\n\ndef test_ais():\n    if (config.mode == 'DEBUG_MODE'):\n        betas = numpy.hstack((numpy.asarray(numpy.linspace(0, 0.5, 10), dtype=config.floatX), numpy.asarray(numpy.linspace(0.5, 0.9, 10), dtype=config.floatX), numpy.asarray(numpy.linspace(0.9, 1.0, 10), dtype=config.floatX)))\n        do_exact = False\n    else:\n        betas = None\n        do_exact = True\n    ais_data('mnistvh.mat', do_exact=do_exact, betas=betas)\n    ais_nodata('mnistvh.mat', do_exact=do_exact, betas=betas)\n", "label": "used", "info": "defuse/train/used/file_1279198.py"}
{"function": "\n\ndef _create_tracks(self, count):\n    for i in range(count):\n        self.library.add(Track(uri=('local:track:%d' % i)))\n", "label": "used", "info": "defuse/train/used/file_1279200.py"}
{"function": "\n\ndef item_link(self, action):\n    return self.get_url(action)\n", "label": "used", "info": "defuse/train/used/file_1279202.py"}
{"function": "\n\ndef _cleanup_servers(self):\n    exception_list = list()\n    for i in self.nova.servers.list():\n        if i.name.startswith(self.new_item_name):\n            self.nova.servers.delete(i)\n            for _ in _utils._iterate_timeout(self.timeout, 'Timeout deleting servers'):\n                try:\n                    self.nova.servers.get(server=i)\n                except nova_exc.NotFound:\n                    break\n                except Exception as e:\n                    exception_list.append(str(e))\n                    continue\n    if exception_list:\n        raise OpenStackCloudException('\\n'.join(exception_list))\n", "label": "used", "info": "defuse/train/used/file_1279206.py"}
{"function": "\n\ndef test_client_add_health_monitor(self):\n    clt = self.client\n    lb = self.loadbalancer\n    lb.manager.add_health_monitor = Mock()\n    fake_type = 'fake'\n    fake_delay = 99\n    fake_timeout = 99\n    fake_attemptsBeforeDeactivation = 99\n    fake_path = '/fake'\n    fake_statusRegex = '.*fake.*'\n    fake_bodyRegex = '.*fake.*'\n    fake_hostHeader = 'fake'\n    clt.add_health_monitor(lb, type=fake_type, delay=fake_delay, timeout=fake_timeout, attemptsBeforeDeactivation=fake_attemptsBeforeDeactivation, path=fake_path, statusRegex=fake_statusRegex, bodyRegex=fake_bodyRegex, hostHeader=fake_hostHeader)\n    lb.manager.add_health_monitor.assert_called_once_with(lb, type=fake_type, delay=fake_delay, timeout=fake_timeout, attemptsBeforeDeactivation=fake_attemptsBeforeDeactivation, path=fake_path, statusRegex=fake_statusRegex, bodyRegex=fake_bodyRegex, hostHeader=fake_hostHeader)\n", "label": "used", "info": "defuse/train/used/file_1279280.py"}
{"function": "\n\ndef setup(self):\n\n    class Double(Compound):\n        field_schema = [Integer.named('x'), Integer.named('y')]\n\n        def compose(self):\n            (ex, ey) = (self.get('x'), self.get('y'))\n            (ux, uy) = (ex.u, ey.u)\n            if (ex.u and ey.u):\n                string = ('%sx%s' % (ex.u, ey.u))\n            else:\n                string = ''\n            if ((ex.value is not None) and (ey.value is not None)):\n                value = (ex.value, ey.value)\n            else:\n                value = None\n            return (string, value)\n\n        def explode(self, value):\n            if (value == 'boom'):\n                raise AttributeError('boom')\n            if (value == 'return-none'):\n                return\n            try:\n                (x, y) = value\n            except (TypeError, ValueError):\n                return False\n            self['x'].set(x)\n            self['y'].set(y)\n            return True\n    self.Double = Double\n", "label": "unused", "info": "defuse/train/unused/file_1279342.py"}
{"function": "\n\ndef evaluateExpression(thread_id, frame_id, expression, doExec):\n    'returns the result of the evaluated expression\\n    @param doExec: determines if we should do an exec or an eval\\n    '\n    frame = findFrame(thread_id, frame_id)\n    expression = expression.replace('@LINE@', '\\n')\n    updated_globals = dict()\n    updated_globals.update(frame.f_globals)\n    updated_globals.update(frame.f_locals)\n    try:\n        if doExec:\n            try:\n                compiled = compile(expression, '<string>', 'eval')\n            except:\n                exec(expression, updated_globals, frame.f_locals)\n            else:\n                result = eval(compiled, updated_globals, frame.f_locals)\n                if (result is not None):\n                    sys.stdout.write(('%s\\n' % (result,)))\n            return\n        else:\n            result = None\n            try:\n                result = eval(expression, updated_globals, frame.f_locals)\n            except Exception:\n                s = StringIO()\n                traceback.print_exc(file=s)\n                result = s.getvalue()\n                try:\n                    try:\n                        (etype, value, tb) = sys.exc_info()\n                        result = value\n                    finally:\n                        etype = value = tb = None\n                except:\n                    pass\n            return result\n    finally:\n        del updated_globals\n        del frame\n", "label": "unused", "info": "defuse/train/unused/file_1279372.py"}
{"function": "\n\ndef reject(self, match=None, match_dict=None, include_accepted=False, include_denied=False):\n    '\\n        Reject public keys. If \"match\" is passed, it is evaluated as a glob.\\n        Pre-gathered matches can also be passed via \"match_dict\".\\n        '\n    if (match is not None):\n        matches = self.name_match(match)\n    elif ((match_dict is not None) and isinstance(match_dict, dict)):\n        matches = match_dict\n    else:\n        matches = {\n            \n        }\n    keydirs = [self.PEND]\n    if include_accepted:\n        keydirs.append(self.ACC)\n    if include_denied:\n        keydirs.append(self.DEN)\n    for keydir in keydirs:\n        for key in matches.get(keydir, []):\n            try:\n                shutil.move(os.path.join(self.opts['pki_dir'], keydir, key), os.path.join(self.opts['pki_dir'], self.REJ, key))\n            except (IOError, OSError):\n                pass\n    self.check_minion_cache()\n    return (self.name_match(match) if (match is not None) else self.dict_match(matches))\n", "label": "used", "info": "defuse/train/used/file_1279376.py"}
{"function": "\n\ndef test_run_no_result(self):\n    self.mox.StubOutWithMock(socket, 'gethostbyaddr')\n    socket.gethostbyaddr('127.0.0.1').AndRaise(socket.herror)\n    self.mox.ReplayAll()\n    ptr = PtrLookup('127.0.0.1')\n    self.assertIsInstance(ptr, gevent.Greenlet)\n    self.assertIsNone(ptr._run())\n", "label": "used", "info": "defuse/train/used/file_1279386.py"}
{"function": "\n\n@classmethod\ndef coloured_access(cls, time, request, code, size, server, who=None):\n    'Generate a consistent coloured response.'\n    if (code >= 500):\n        command = ColouredWriter.colors['fail']\n    elif (code >= 400):\n        command = ColouredWriter.colors['warning']\n    elif (code == 301):\n        command = ColouredWriter.colors['fail']\n    elif (code >= 300):\n        command = ColouredWriter.colors['okgreen']\n    elif (code >= 200):\n        command = ColouredWriter.colors['okblue']\n    else:\n        command = ColouredWriter.colors['unknown']\n    if (code in ColouredWriter.status_code_text):\n        meaning = ColouredWriter.status_code_text[code]\n    else:\n        meaning = '*unknown*'\n    endc = ColouredWriter.colors['endc']\n    if (who is None):\n        line = ('%s %s %s%s%s %i %i (%s)\\n' % (server[:3], time, command, request, endc, code, size, meaning))\n    else:\n        line = ('%s %s %s %s%s%s %i %i (%s)\\n' % (server[:3], time, who, command, request, endc, code, size, meaning))\n    return line\n", "label": "used", "info": "defuse/train/used/file_1279392.py"}
{"function": "\n\ndef list_apikeys(self, name):\n    '\\n        TODO: add docstring\\n        => [apikey:str]\\n        '\n    with self.get(('/v3/user/apikey/list/%s' % urlquote(str(name)))) as res:\n        (code, body) = (res.status, res.read())\n        if (code != 200):\n            self.raise_error('List API keys failed', res, body)\n        js = self.checked_json(body, ['apikeys'])\n        return js['apikeys']\n", "label": "used", "info": "defuse/train/used/file_1279404.py"}
{"function": "\n\n@blueprint.route('/stdout', methods=['GET'])\n@api_wrapper\n@require_login\n@require_team\n@block_before_competition(\"You can't view problems before the competition starts!\")\ndef programming_stdout_hook():\n    if ((request.args.get('token') is None) or (len(request.args.get('token')) < 1)):\n        raise WebException('Please provide a token.')\n    token = request.args.get('token')\n    db = api.common.db_conn()\n    program = db.programs.find_one({\n        'token': token,\n    })\n    if (program is None):\n        raise WebException('Could not find program.')\n    if ('log' not in program):\n        raise WebException('Could not find log.')\n    return {\n        'success': 1,\n        'pid': program['pid'],\n        'timestamp': program['timestamp'],\n        'data': program['log'],\n    }\n", "label": "used", "info": "defuse/train/used/file_1279412.py"}
{"function": "\n\ndef testEncounter8(self):\n    inst = self.instantiate_from('encounter-example-xcda.json')\n    self.assertIsNotNone(inst, 'Must have instantiated a Encounter instance')\n    self.implEncounter8(inst)\n    js = inst.as_json()\n    self.assertEqual('Encounter', js['resourceType'])\n    inst2 = encounter.Encounter(js)\n    self.implEncounter8(inst2)\n", "label": "used", "info": "defuse/train/used/file_1279414.py"}
{"function": "\n\ndef exists(zpool):\n    \"\\n    Check if a ZFS storage pool is active\\n\\n    zpool : string\\n        name of storage pool\\n\\n    CLI Example:\\n\\n    .. code-block:: bash\\n\\n        salt '*' zpool.exists myzpool\\n    \"\n    zpool_cmd = _check_zpool()\n    cmd = '{zpool_cmd} list {zpool}'.format(zpool_cmd=zpool_cmd, zpool=zpool)\n    res = __salt__['cmd.run_all'](cmd, python_shell=False)\n    if (res['retcode'] != 0):\n        return False\n    return True\n", "label": "used", "info": "defuse/train/used/file_1279416.py"}
{"function": "\n\ndef topic(self, parent_topic):\n    (factory, context) = parent_topic\n    return factory.create_instances(context, 'my_string_filter(aaaa):my_string_filter(bbb):my_pre_load_filter(ccc)')\n", "label": "used", "info": "defuse/train/used/file_1279418.py"}
{"function": "\n\ndef test_util_from_n3_sisnonenodefault(self):\n    s = None\n    default = None\n    res = util.from_n3(s, default=default, backend=None)\n    self.assert_((res == default))\n", "label": "used", "info": "defuse/train/used/file_1279422.py"}
{"function": "\n\ndef __exit__(self, type, value, traceback):\n    if (type is None):\n        self.close()\n    else:\n        self.abort()\n", "label": "used", "info": "defuse/train/used/file_1279424.py"}
{"function": "\n\ndef _start_where(self, attrsD):\n    self.push('where', 0)\n    context = self._getContext()\n    context['where'] = FeedParserDict()\n", "label": "used", "info": "defuse/train/used/file_1279430.py"}
{"function": "\n\ndef testCustomNoduleTangentsPreferInputIfAvailable(self):\n    s = Gaffer.ScriptNode()\n    s['n1'] = GafferTest.AddNode()\n    s['n2'] = GafferTest.AddNode()\n    s['n2']['op1'].setInput(s['n1']['sum'])\n    Gaffer.Metadata.registerPlugValue(s['n1']['sum'], 'nodeGadget:nodulePosition', 'right')\n    s['d'] = Gaffer.Dot()\n    g = GafferUI.NodeGadget.create(s['d'])\n    s['d'].setup(s['n2']['op1'])\n    self.assertEqual(g.noduleTangent(g.nodule(s['d']['in'])), IECore.V3f((- 1), 0, 0))\n    self.assertEqual(g.noduleTangent(g.nodule(s['d']['out'])), IECore.V3f(1, 0, 0))\n", "label": "used", "info": "defuse/train/used/file_1279440.py"}
{"function": "\n\ndef errcheck_int(result, func, arguments):\n    'Raise an error if return integer is less than 0'\n    if (result < 0):\n        cookie = arguments[0]\n        errno = magic_errno(cookie)\n        error = magic_error(cookie)\n        raise MagicError(errno, error)\n    return result\n", "label": "used", "info": "defuse/train/used/file_1279448.py"}
{"function": "\n\ndef _get_descending_key(gettime=time.time):\n    'Returns a key name lexically ordered by time descending.\\n\\n  This lets us have a key name for use with Datastore entities which returns\\n  rows in time descending order when it is scanned in lexically ascending order,\\n  allowing us to bypass index building for descending indexes.\\n\\n  Args:\\n    gettime: Used for testing.\\n\\n  Returns:\\n    A string with a time descending key.\\n  '\n    now_descending = int(((_FUTURE_TIME - gettime()) * 100))\n    request_id_hash = os.environ.get('REQUEST_ID_HASH', '')\n    random_bits = random.getrandbits(32)\n    return ('%d%s%s' % (now_descending, random_bits, request_id_hash))\n", "label": "used", "info": "defuse/train/used/file_1279452.py"}
{"function": "\n\ndef test_ping(self):\n    self.CANEngine = CANSploit()\n    self.CANEngine.load_config('tests/test_2.py')\n    self.CANEngine.edit_module(0, {\n        'pipe': 2,\n        'body': '000000000000010203040506070102030405060711121314151617a1a2a3a4a5a6a7112233',\n        'range': [542999, 543002],\n        'mode': 'isotp',\n    })\n    self.CANEngine.start_loop()\n    time.sleep(1)\n    self.CANEngine.call_module(0, 's')\n    time.sleep(1)\n    index = 3\n    ret = self.CANEngine.call_module(3, 'p')\n    _bodyList = self.CANEngine._enabledList[index][1]._bodyList\n    self.assertTrue((543000 in _bodyList), 'We should be able to find ID 543000')\n    self.assertFalse((543002 in _bodyList), 'We should not be able to find ID 543002')\n    self.assertTrue(([1, 1, 1, 1, 1, 1] == list(_bodyList[543001].values())), 'We should not be able to find ID')\n    self.assertTrue(('25112233' == codecs.encode(list(_bodyList[543001].keys())[5][1], 'hex_codec').decode('ISO-8859-1')), 'Last packet of sec should be like that')\n    self.assertTrue(('24a1a2a3a4a5a6a7' == codecs.encode(list(_bodyList[543001].keys())[4][1], 'hex_codec').decode('ISO-8859-1')), 'Last packet of sec should be like that')\n", "label": "unused", "info": "defuse/train/unused/file_1279466.py"}
