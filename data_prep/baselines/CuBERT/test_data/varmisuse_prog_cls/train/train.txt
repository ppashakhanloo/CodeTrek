{"function": "\n\n@classmethod\ndef cast(cls, value, loc):\n    '\\n        A node for implicit casting at the return statement\\n        '\n    op = 'cast'\n    return cls(op=op, value=value, loc=loc)\n", "label": "correct", "info": "dataset/ETHPy150Open numba/numba/numba/ir.py Expr.cast/original"}
{"function": "\n\n@classmethod\ndef cast(cls, value, loc):\n    '\\n        A node for implicit casting at the return statement\\n        '\n    op = 'cast'\n    return cls(op=op, value=value, loc=cls)\n", "label": "misuse", "info": "dataset/ETHPy150Open numba/numba/numba/ir.py Expr.cast/VarMisuse@36/62 `loc`->`cls`"}
{"function": "\n\ndef string_to_classes(s):\n    if (s == '*'):\n        c = sorted(six.iterkeys(tracked_classes))\n        return c\n    else:\n        return s.split()\n", "label": "correct", "info": "dataset/ETHPy150Open PyTables/PyTables/tables/utils.py string_to_classes/original"}
{"function": "\n\ndef string_to_classes(s):\n    if (c == '*'):\n        c = sorted(six.iterkeys(tracked_classes))\n        return c\n    else:\n        return s.split()\n", "label": "misuse", "info": "dataset/ETHPy150Open PyTables/PyTables/tables/utils.py string_to_classes/VarMisuse@12/15 `s`->`c`"}
{"function": "\n\ndef __init__(self, board, name, uuid=None, details=None, backend=None, book=None, book_data=None):\n    if uuid:\n        self._uuid = uuid\n    else:\n        self._uuid = uuidutils.generate_uuid()\n    self._name = name\n    if (not details):\n        details = {\n            \n        }\n    self._details = details\n    self._backend = backend\n    self._board = board\n    self._book = book\n    if (not book_data):\n        book_data = {\n            \n        }\n    self._book_data = book_data\n", "label": "correct", "info": "dataset/ETHPy150Open openstack/taskflow/taskflow/jobs/base.py Job.__init__/original"}
{"function": "\n\ndef __init__(self, board, name, uuid=None, details=None, backend=None, book=None, book_data=None):\n    if uuid:\n        self._uuid = uuid\n    else:\n        self._uuid = uuidutils.generate_uuid()\n    self._name = name\n    if (not details):\n        details = {\n            \n        }\n    self._details = details\n    self._backend = backend\n    self._board = board\n    self._book = book\n    if (not book_data):\n        book_data = {\n            \n        }\n    name._book_data = book_data\n", "label": "misuse", "info": "dataset/ETHPy150Open openstack/taskflow/taskflow/jobs/base.py Job.__init__/VarMisuse@123/144 `self`->`name`"}
{"function": "\n\ndef get_random_ip_address(version=4):\n    if (version == 4):\n        ip_string = ('10.%d.%d.%d' % (random.randint(3, 254), random.randint(3, 254), random.randint(3, 254)))\n        return netaddr.IPAddress(ip_string)\n    else:\n        ip = ipv6_utils.get_ipv6_addr_by_EUI64('2001:db8::/64', get_random_mac())\n        return ip\n", "label": "correct", "info": "dataset/ETHPy150Open openstack/neutron/neutron/tests/tools.py get_random_ip_address/original"}
{"function": "\n\ndef get_random_ip_address(version=4):\n    if (ip == 4):\n        ip_string = ('10.%d.%d.%d' % (random.randint(3, 254), random.randint(3, 254), random.randint(3, 254)))\n        return netaddr.IPAddress(ip_string)\n    else:\n        ip = ipv6_utils.get_ipv6_addr_by_EUI64('2001:db8::/64', get_random_mac())\n        return ip\n", "label": "misuse", "info": "dataset/ETHPy150Open openstack/neutron/neutron/tests/tools.py get_random_ip_address/VarMisuse@14/18 `version`->`ip`"}
{"function": "\n\ndef load_from_db():\n    '\\n    Load miners from database\\n    '\n    columns = ['Username TEXT', 'Password TEXT']\n    bitHopper.Database.Commands.Create_Table('Miners', columns)\n    results = bitHopper.Database.execute('SELECT Username, Password FROM Miners')\n    miners = set()\n    for (username, password) in results:\n        miners.add((username, password))\n    return miners\n", "label": "correct", "info": "dataset/ETHPy150Open c00w/bitHopper/bitHopper/Configuration/Miners.py load_from_db/original"}
{"function": "\n\ndef load_from_db():\n    '\\n    Load miners from database\\n    '\n    columns = ['Username TEXT', 'Password TEXT']\n    bitHopper.Database.Commands.Create_Table('Miners', columns)\n    results = bitHopper.Database.execute('SELECT Username, Password FROM Miners')\n    miners = set()\n    for (username, password) in results:\n        miners.add((username, results))\n    return miners\n", "label": "misuse", "info": "dataset/ETHPy150Open c00w/bitHopper/bitHopper/Configuration/Miners.py load_from_db/VarMisuse@67/116 `password`->`results`"}
{"function": "\n\ndef _fuzzy_group(args, quick_exit=False):\n    'Return True if all args are True, None if there is any None else False\\n    unless ``quick_exit`` is True (then return None as soon as a second False\\n    is seen.\\n\\n     ``_fuzzy_group`` is like ``fuzzy_and`` except that it is more\\n    conservative in returning a False, waiting to make sure that all\\n    arguments are True or False and returning None if any arguments are\\n    None. It also has the capability of permiting only a single False and\\n    returning None if more than one is seen. For example, the presence of a\\n    single transcendental amongst rationals would indicate that the group is\\n    no longer rational; but a second transcendental in the group would make the\\n    determination impossible.\\n\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.core.logic import _fuzzy_group\\n\\n    By default, multiple Falses mean the group is broken:\\n\\n    >>> _fuzzy_group([False, False, True])\\n    False\\n\\n    If multiple Falses mean the group status is unknown then set\\n    `quick_exit` to True so None can be returned when the 2nd False is seen:\\n\\n    >>> _fuzzy_group([False, False, True], quick_exit=True)\\n\\n    But if only a single False is seen then the group is known to\\n    be broken:\\n\\n    >>> _fuzzy_group([False, True, True], quick_exit=True)\\n    False\\n\\n    '\n    saw_other = False\n    for a in args:\n        if (a is True):\n            continue\n        if (a is None):\n            return\n        if (quick_exit and saw_other):\n            return\n        saw_other = True\n    return (not saw_other)\n", "label": "correct", "info": "dataset/ETHPy150Open sympy/sympy/sympy/core/logic.py _fuzzy_group/original"}
{"function": "\n\ndef _fuzzy_group(args, quick_exit=False):\n    'Return True if all args are True, None if there is any None else False\\n    unless ``quick_exit`` is True (then return None as soon as a second False\\n    is seen.\\n\\n     ``_fuzzy_group`` is like ``fuzzy_and`` except that it is more\\n    conservative in returning a False, waiting to make sure that all\\n    arguments are True or False and returning None if any arguments are\\n    None. It also has the capability of permiting only a single False and\\n    returning None if more than one is seen. For example, the presence of a\\n    single transcendental amongst rationals would indicate that the group is\\n    no longer rational; but a second transcendental in the group would make the\\n    determination impossible.\\n\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.core.logic import _fuzzy_group\\n\\n    By default, multiple Falses mean the group is broken:\\n\\n    >>> _fuzzy_group([False, False, True])\\n    False\\n\\n    If multiple Falses mean the group status is unknown then set\\n    `quick_exit` to True so None can be returned when the 2nd False is seen:\\n\\n    >>> _fuzzy_group([False, False, True], quick_exit=True)\\n\\n    But if only a single False is seen then the group is known to\\n    be broken:\\n\\n    >>> _fuzzy_group([False, True, True], quick_exit=True)\\n    False\\n\\n    '\n    saw_other = False\n    for a in args:\n        if (a is True):\n            continue\n        if (a is None):\n            return\n        if (quick_exit and a):\n            return\n        saw_other = True\n    return (not saw_other)\n", "label": "misuse", "info": "dataset/ETHPy150Open sympy/sympy/sympy/core/logic.py _fuzzy_group/VarMisuse@55/601 `saw_other`->`a`"}
{"function": "\n\ndef test_matching_tplquad(self):\n\n    def func3d(x0, x1, x2, c0, c1):\n        return (((((x0 ** 2) + (c0 * (x1 ** 3))) - (x0 * x1)) + 1) + (c1 * np.sin(x2)))\n    res = tplquad(func3d, (- 1), 2, (lambda x: (- 2)), (lambda x: 2), (lambda x, y: (- np.pi)), (lambda x, y: np.pi), args=(2, 3))\n    res2 = nquad(func3d, [[(- np.pi), np.pi], [(- 2), 2], ((- 1), 2)], args=(2, 3))\n    assert_almost_equal(res, res2)\n", "label": "correct", "info": "dataset/ETHPy150Open scipy/scipy/scipy/integrate/tests/test_quadpack.py TestNQuad.test_matching_tplquad/original"}
{"function": "\n\ndef test_matching_tplquad(self):\n\n    def func3d(x0, x1, x2, c0, c1):\n        return (((((x0 ** 2) + (c0 * (x1 ** 3))) - (x0 * x1)) + 1) + (c1 * np.sin(x2)))\n    res = tplquad(func3d, (- 1), 2, (lambda x: (- 2)), (lambda x: 2), (lambda x, y: (- np.pi)), (lambda x, y: np.pi), args=(2, 3))\n    res2 = nquad(func3d, [[(- np.pi), np.pi], [(- 2), 2], ((- 1), 2)], args=(2, 3))\n    assert_almost_equal(res2, res2)\n", "label": "misuse", "info": "dataset/ETHPy150Open scipy/scipy/scipy/integrate/tests/test_quadpack.py TestNQuad.test_matching_tplquad/VarMisuse@186/199 `res`->`res2`"}
{"function": "\n\n@property\ndef owner(self):\n    return ', '.join(list(set([t.owner for t in self.tasks])))\n", "label": "correct", "info": "dataset/ETHPy150Open airbnb/airflow/airflow/models.py DAG.owner/original"}
{"function": "\n\n@property\ndef owner(self):\n    return ', '.join(list(set([t.owner for t in t.tasks])))\n", "label": "misuse", "info": "dataset/ETHPy150Open airbnb/airflow/airflow/models.py DAG.owner/VarMisuse@29/32 `self`->`t`"}
{"function": "\n\ndef test_extended_stats_aggregation(self):\n    json_output = {\n        'query': {\n            'filtered': {\n                'filter': {\n                    'and': [{\n                        'match_all': {\n                            \n                        },\n                    }],\n                },\n                'query': {\n                    'match_all': {\n                        \n                    },\n                },\n            },\n        },\n        'aggs': {\n            'name_stats': {\n                'extended_stats': {\n                    'field': 'name',\n                    'script': 'MY weird script',\n                },\n            },\n        },\n        'size': SIZE_LIMIT,\n    }\n    query = HQESQuery('cases').aggregation(ExtendedStatsAggregation('name_stats', 'name', script='MY weird script'))\n    self.checkQuery(query, json_output)\n", "label": "correct", "info": "dataset/ETHPy150Open dimagi/commcare-hq/corehq/apps/es/tests/test_aggregations.py TestAggregations.test_extended_stats_aggregation/original"}
{"function": "\n\ndef test_extended_stats_aggregation(self):\n    json_output = {\n        'query': {\n            'filtered': {\n                'filter': {\n                    'and': [{\n                        'match_all': {\n                            \n                        },\n                    }],\n                },\n                'query': {\n                    'match_all': {\n                        \n                    },\n                },\n            },\n        },\n        'aggs': {\n            'name_stats': {\n                'extended_stats': {\n                    'field': 'name',\n                    'script': 'MY weird script',\n                },\n            },\n        },\n        'size': SIZE_LIMIT,\n    }\n    query = HQESQuery('cases').aggregation(ExtendedStatsAggregation('name_stats', 'name', script='MY weird script'))\n    query.checkQuery(query, json_output)\n", "label": "misuse", "info": "dataset/ETHPy150Open dimagi/commcare-hq/corehq/apps/es/tests/test_aggregations.py TestAggregations.test_extended_stats_aggregation/VarMisuse@126/199 `self`->`query`"}
{"function": "\n\ndef dmp_irreducible_p(self, f):\n    return dmp_irreducible_p(self.to_dense(f), (self.ngens - 1), self.domain)\n", "label": "correct", "info": "dataset/ETHPy150Open sympy/sympy/sympy/polys/compatibility.py IPolys.dmp_irreducible_p/original"}
{"function": "\n\ndef dmp_irreducible_p(self, f):\n    return dmp_irreducible_p(f.to_dense(f), (self.ngens - 1), self.domain)\n", "label": "misuse", "info": "dataset/ETHPy150Open sympy/sympy/sympy/polys/compatibility.py IPolys.dmp_irreducible_p/VarMisuse@15/28 `self`->`f`"}
{"function": "\n\n@synchronized('arbiter_reload')\n@gen.coroutine\n@debuglog\ndef reload(self, graceful=True, sequential=False):\n    'Reloads everything.\\n\\n        Run the :func:`prereload_fn` callable if any, then gracefuly\\n        reload all watchers.\\n        '\n    if self._stopping:\n        return\n    if (self.prereload_fn is not None):\n        self.prereload_fn(self)\n    for handler in logger.handlers:\n        if isinstance(handler, logging.FileHandler):\n            handler.acquire()\n            handler.stream.close()\n            handler.stream = open(handler.baseFilename, handler.mode)\n            handler.release()\n    for watcher in self.iter_watchers():\n        (yield watcher._reload(graceful=graceful, sequential=sequential))\n        tornado_sleep(self.warmup_delay)\n", "label": "correct", "info": "dataset/ETHPy150Open circus-tent/circus/circus/arbiter.py Arbiter.reload/original"}
{"function": "\n\n@synchronized('arbiter_reload')\n@gen.coroutine\n@debuglog\ndef reload(self, graceful=True, sequential=False):\n    'Reloads everything.\\n\\n        Run the :func:`prereload_fn` callable if any, then gracefuly\\n        reload all watchers.\\n        '\n    if self._stopping:\n        return\n    if (self.prereload_fn is not None):\n        self.prereload_fn(self)\n    for handler in logger.handlers:\n        if isinstance(handler, logging.FileHandler):\n            handler.acquire()\n            handler.stream.close()\n            handler.stream = open(handler.baseFilename, handler.mode)\n            handler.release()\n    for watcher in self.iter_watchers():\n        (yield watcher._reload(graceful=self, sequential=sequential))\n        tornado_sleep(self.warmup_delay)\n", "label": "misuse", "info": "dataset/ETHPy150Open circus-tent/circus/circus/arbiter.py Arbiter.reload/VarMisuse@141/217 `graceful`->`self`"}
{"function": "\n\ndef test_unresponsive_stop(pyscript):\n    script = pyscript(\"\\n        import signal\\n        import sys\\n        import time\\n        from daemonocle import Daemon\\n\\n        def worker():\\n            def handle_sigterm(*args, **kwargs):\\n                time.sleep(10)\\n\\n            signal.signal(signal.SIGTERM, handle_sigterm)\\n            time.sleep(10)\\n\\n        daemon = Daemon(worker=worker, prog='foo', pidfile='foo.pid',\\n                        stop_timeout=1)\\n        daemon.do_action(sys.argv[1])\\n    \")\n    pidfile = os.path.realpath(os.path.join(script.dirname, 'foo.pid'))\n    script.run('start')\n    with open(pidfile, 'rb') as f:\n        pid = int(f.read())\n    result = script.run('stop')\n    assert (result.returncode == 1)\n    assert (result.stdout == b'Stopping foo ... FAILED\\n')\n    assert (result.stderr == 'ERROR: Timed out while waiting for process (PID {pid}) to terminate\\n'.format(pid=pid).encode('utf-8'))\n    assert psutil.pid_exists(pid)\n    os.kill(pid, signal.SIGKILL)\n    try:\n        proc = psutil.Process(pid)\n    except psutil.NoSuchProcess:\n        pass\n    else:\n        proc.wait(timeout=1)\n", "label": "correct", "info": "dataset/ETHPy150Open jnrbsn/daemonocle/tests/test_shutdown.py test_unresponsive_stop/original"}
{"function": "\n\ndef test_unresponsive_stop(pyscript):\n    script = result(\"\\n        import signal\\n        import sys\\n        import time\\n        from daemonocle import Daemon\\n\\n        def worker():\\n            def handle_sigterm(*args, **kwargs):\\n                time.sleep(10)\\n\\n            signal.signal(signal.SIGTERM, handle_sigterm)\\n            time.sleep(10)\\n\\n        daemon = Daemon(worker=worker, prog='foo', pidfile='foo.pid',\\n                        stop_timeout=1)\\n        daemon.do_action(sys.argv[1])\\n    \")\n    pidfile = os.path.realpath(os.path.join(script.dirname, 'foo.pid'))\n    script.run('start')\n    with open(pidfile, 'rb') as f:\n        pid = int(f.read())\n    result = script.run('stop')\n    assert (result.returncode == 1)\n    assert (result.stdout == b'Stopping foo ... FAILED\\n')\n    assert (result.stderr == 'ERROR: Timed out while waiting for process (PID {pid}) to terminate\\n'.format(pid=pid).encode('utf-8'))\n    assert psutil.pid_exists(pid)\n    os.kill(pid, signal.SIGKILL)\n    try:\n        proc = psutil.Process(pid)\n    except psutil.NoSuchProcess:\n        pass\n    else:\n        proc.wait(timeout=1)\n", "label": "misuse", "info": "dataset/ETHPy150Open jnrbsn/daemonocle/tests/test_shutdown.py test_unresponsive_stop/VarMisuse@12/20 `pyscript`->`result`"}
{"function": "\n\ndef setUp(self):\n    super(SaharaOutputDataSourcesTestCase, self).setUp()\n    fake_dict = FakeDict()\n    fake_dict.__dict__['username'] = 'user'\n    fake_dict.__dict__['password'] = 'passwd'\n    self.tenants_num = 2\n    self.users_per_tenant = 2\n    self.users = (self.tenants_num * self.users_per_tenant)\n    self.task = mock.MagicMock()\n    self.tenants = {\n        \n    }\n    self.users_key = []\n    for i in range(self.tenants_num):\n        self.tenants[str(i)] = {\n            'id': str(i),\n            'name': str(i),\n            'sahara': {\n                'image': '42',\n            },\n        }\n        for j in range(self.users_per_tenant):\n            self.users_key.append({\n                'id': ('%s_%s' % (str(i), str(j))),\n                'tenant_id': str(i),\n                'credential': fake_dict,\n            })\n    self.user_key = [{\n        'id': i,\n        'tenant_id': j,\n        'credential': 'credential',\n    } for j in range(self.tenants_num) for i in range(self.users_per_tenant)]\n    self.context.update({\n        'config': {\n            'users': {\n                'tenants': self.tenants_num,\n                'users_per_tenant': self.users_per_tenant,\n            },\n            'sahara_output_data_sources': {\n                'output_type': 'hdfs',\n                'output_url_prefix': 'hdfs://test_host/',\n            },\n        },\n        'admin': {\n            'credential': mock.MagicMock(),\n        },\n        'task': mock.MagicMock(),\n        'users': self.users_key,\n        'tenants': self.tenants,\n    })\n", "label": "correct", "info": "dataset/ETHPy150Open openstack/rally/tests/unit/plugins/openstack/context/sahara/test_sahara_output_data_sources.py SaharaOutputDataSourcesTestCase.setUp/original"}
{"function": "\n\ndef setUp(self):\n    super(SaharaOutputDataSourcesTestCase, self).setUp()\n    fake_dict = FakeDict()\n    fake_dict.__dict__['username'] = 'user'\n    fake_dict.__dict__['password'] = 'passwd'\n    self.tenants_num = 2\n    self.users_per_tenant = 2\n    self.users = (self.tenants_num * self.users_per_tenant)\n    self.task = mock.MagicMock()\n    self.tenants = {\n        \n    }\n    self.users_key = []\n    for i in range(self.tenants_num):\n        j.tenants[str(i)] = {\n            'id': str(i),\n            'name': str(i),\n            'sahara': {\n                'image': '42',\n            },\n        }\n        for j in range(self.users_per_tenant):\n            self.users_key.append({\n                'id': ('%s_%s' % (str(i), str(j))),\n                'tenant_id': str(i),\n                'credential': fake_dict,\n            })\n    self.user_key = [{\n        'id': i,\n        'tenant_id': j,\n        'credential': 'credential',\n    } for j in range(self.tenants_num) for i in range(self.users_per_tenant)]\n    self.context.update({\n        'config': {\n            'users': {\n                'tenants': self.tenants_num,\n                'users_per_tenant': self.users_per_tenant,\n            },\n            'sahara_output_data_sources': {\n                'output_type': 'hdfs',\n                'output_url_prefix': 'hdfs://test_host/',\n            },\n        },\n        'admin': {\n            'credential': mock.MagicMock(),\n        },\n        'task': mock.MagicMock(),\n        'users': self.users_key,\n        'tenants': self.tenants,\n    })\n", "label": "misuse", "info": "dataset/ETHPy150Open openstack/rally/tests/unit/plugins/openstack/context/sahara/test_sahara_output_data_sources.py SaharaOutputDataSourcesTestCase.setUp/VarMisuse@109/149 `self`->`j`"}
